"""
Base classes for signals-based strategy framework.
"""

from dataclasses import dataclass
from typing import Dict, Any, List
import datetime as dt


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.
    
    Attributes:
        ts: ISO timestamp of signal generation
        symbol: Trading symbol (e.g., "SPY", "QQQ")
        strategy: Name of the strategy that generated the signal
        action: Signal action - "enter", "exit", or "hold"
        confidence: Confidence level from 0.0 to 1.0
        notes: Additional context or reasoning
    """
    ts: str
    symbol: str
    strategy: str
    action: str         # "enter", "exit", "hold"
    confidence: float   # 0..1
    notes: str = ""

    @staticmethod
    def now_iso() -> str:
        """Generate current UTC timestamp in ISO format."""
        return dt.datetime.now(dt.timezone.utc).isoformat()

    def __post_init__(self):
        """Validate signal data after initialization."""
        if self.action not in {"enter", "exit", "hold"}:
            raise ValueError(f"Invalid action: {self.action}. Must be 'enter', 'exit', or 'hold'")
        
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Invalid confidence: {self.confidence}. Must be between 0.0 and 1.0")


class BaseStrategy:
    """
    Base class for all signals-based strategies.
    
    This provides a different approach from the existing options strategies,
    focusing on signal generation rather than direct order creation.
    """
    
    name: str = "base"

    def __init__(self, config: Dict[str, Any] | None = None):
        """
        Initialize strategy with optional configuration.
        
        Args:
            config: Dictionary of strategy-specific configuration parameters
        """
        self.config = config or {}
        self._initialized = False

    def warmup(self, **kwargs) -> None:
        """
        Load any caches, models, or perform initialization.
        
        This method is called once before strategy evaluation begins.
        Override in subclasses to implement strategy-specific setup.
        """
        self._initialized = True

    def evaluate(self, md: Dict[str, Any]) -> List[Signal]:
        """
        Evaluate market data and return trading signals.
        
        Args:
            md: Market data dictionary containing symbol, indicators, and metrics
            
        Returns:
            List of Signal objects representing trading recommendations
            
        Raises:
            NotImplementedError: Must be implemented by subclasses
        """
        raise NotImplementedError(f"Strategy {self.name} must implement evaluate() method")

    def get_config(self, key: str, default: Any = None) -> Any:
        """
        Get configuration value with optional default.
        
        Args:
            key: Configuration key to retrieve
            default: Default value if key not found
            
        Returns:
            Configuration value or default
        """
        return self.config.get(key, default)

    def validate_market_data(self, md: Dict[str, Any]) -> bool:
        """
        Validate that market data contains required fields.
        
        Args:
            md: Market data dictionary to validate
            
        Returns:
            True if market data is valid, False otherwise
        """
        required_fields = ["symbol"]
        return all(field in md for field in required_fields)

    def __repr__(self) -> str:
        """String representation of the strategy."""
        return f"{self.__class__.__name__}(name='{self.name}', config={self.config})"